AWSTemplateFormatVersion: '2010-09-09'
Description: 'Clawdbot - AWS Native Deployment (Bedrock + SSM + VPC Endpoints)'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Basic Configuration"
        Parameters:
          - ClawdbotModel
          - InstanceType
          - KeyPairName
      - Label:
          default: "Network Configuration"
        Parameters:
          - CreateVPCEndpoints
          - AllowedSSHCIDR
      - Label:
          default: "Advanced Configuration"
        Parameters:
          - EnableSandbox
          - AutoEnableBedrock

Parameters:
  ClawdbotModel:
    Type: String
    Default: "us.anthropic.claude-sonnet-4-5-20250929-v1:0"
    Description: "Bedrock model ID (use region-specific prefix: us./eu./apac.)"
    AllowedValues:
      - "us.anthropic.claude-sonnet-4-5-20250929-v1:0"
      - "global.anthropic.claude-sonnet-4-5-20250929-v1:0"
      - "anthropic.claude-sonnet-4-20250514-v1:0"
      - "anthropic.claude-3-5-sonnet-20241022-v2:0"
      - "anthropic.claude-opus-4-20250514"
      - "us.amazon.nova-pro-v1:0"
      - "anthropic.claude-3-haiku-20240307-v1:0"

  InstanceType:
    Type: String
    Default: "t3.medium"
    AllowedValues:
      - "t3.small"
      - "t3.medium"
      - "t3.large"
      - "t3.xlarge"
      - "c5.xlarge"

  KeyPairName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: "EC2 key pair for emergency SSH access"

  AllowedSSHCIDR:
    Type: String
    Default: "0.0.0.0/0"
    Description: "CIDR for SSH access (recommend SSM Session Manager, set to 127.0.0.1/32 to disable SSH)"

  CreateVPCEndpoints:
    Type: String
    Default: "true"
    Description: "Create VPC endpoints for private network access to Bedrock and SSM"
    AllowedValues:
      - "true"
      - "false"

  EnableSandbox:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"

  AutoEnableBedrock:
    Type: String
    Default: "false"
    Description: "Automatically run pre-check and attempt to enable Bedrock models"
    AllowedValues:
      - "true"
      - "false"

Conditions:
  CreateEndpoints: !Equals [!Ref CreateVPCEndpoints, "true"]
  AllowSSH: !Not [!Equals [!Ref AllowedSSHCIDR, "127.0.0.1/32"]]
  RunPrecheck: !Equals [!Ref AutoEnableBedrock, "true"]

Mappings:
  RegionMap:
    us-east-1:
      AMI: "ami-0c7217cdde317cfec"
    us-east-2:
      AMI: "ami-0ea3c35c5c3284d82"
    us-west-1:
      AMI: "ami-0ce2cb35386fc22e9"
    us-west-2:
      AMI: "ami-0aff18ec83b58762f"
    eu-west-1:
      AMI: "ami-0e9085e60087ce171"
    eu-central-1:
      AMI: "ami-0084a47cc718c111a"
    ap-southeast-1:
      AMI: "ami-0497a974f8d5dcef8"
    ap-northeast-1:
      AMI: "ami-0d52744d6551d851e"
    ap-south-1:
      AMI: "ami-0dee22c13ea7a9a67"

Resources:
  # ==================== Wait Condition for Token ====================
  ClawdbotWaitHandle:
    Type: AWS::CloudFormation::WaitConditionHandle

  ClawdbotWaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    DependsOn: ClawdbotInstance
    Properties:
      Handle: !Ref ClawdbotWaitHandle
      Timeout: '900'
      Count: 1

  # ==================== Pre-Check Lambda ====================
  PrecheckLambdaRole:
    Type: AWS::IAM::Role
    Condition: RunPrecheck
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: BedrockPrecheckPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'bedrock:ListFoundationModels'
                  - 'bedrock:GetFoundationModel'
                  - 'bedrock:InvokeModel'
                  - 'bedrock-runtime:InvokeModel'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'ec2:DescribeVpcEndpoints'
                  - 'servicequotas:GetServiceQuota'
                  - 'sts:GetCallerIdentity'
                Resource: '*'

  PrecheckLambdaFunction:
    Type: AWS::Lambda::Function
    Condition: RunPrecheck
    DependsOn: PrecheckLambdaRole
    Properties:
      FunctionName: !Sub '${AWS::StackName}-bedrock-precheck'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt PrecheckLambdaRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import urllib3
          from botocore.exceptions import ClientError
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          http = urllib3.PoolManager()
          
          def send_response(event, context, status, data):
              """Send response to CloudFormation"""
              response_body = {
                  'Status': status,
                  'Reason': f'See CloudWatch Log Stream: {context.log_stream_name}',
                  'PhysicalResourceId': context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': data
              }
              
              json_response = json.dumps(response_body)
              headers = {'content-type': '', 'content-length': str(len(json_response))}
              
              try:
                  http.request('PUT', event['ResponseURL'], body=json_response, headers=headers)
                  logger.info(f"Response sent successfully: {status}")
              except Exception as e:
                  logger.error(f"Failed to send response: {e}")
          
          def lambda_handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              try:
                  request_type = event.get('RequestType')
                  
                  # Handle Delete - no action needed
                  if request_type == 'Delete':
                      send_response(event, context, 'SUCCESS', {'Message': 'Delete completed'})
                      return
                  
                  # Get model ID from properties
                  model_id = event.get('ResourceProperties', {}).get('ModelId', 
                              'anthropic.claude-3-5-sonnet-20241022-v2:0')
                  
                  bedrock = boto3.client('bedrock')
                  bedrock_runtime = boto3.client('bedrock-runtime')
                  
                  results = {'checks_passed': 0, 'model_id': model_id}
                  
                  # Check 1: Bedrock service
                  logger.info("Check 1/3: Bedrock service availability")
                  try:
                      bedrock.list_foundation_models(byProvider='Anthropic')
                      results['bedrock_available'] = True
                      results['checks_passed'] += 1
                      logger.info("✓ Bedrock service available")
                  except ClientError as e:
                      logger.error(f"✗ Bedrock check failed: {e}")
                      send_response(event, context, 'FAILED', 
                                  {'Error': 'Bedrock not available in this region'})
                      return
                  
                  # Check 2: Model access
                  logger.info(f"Check 2/3: Model access for {model_id}")
                  try:
                      models_response = bedrock.list_foundation_models(byProvider='Anthropic')
                      available_models = {m['modelId']: m for m in models_response.get('modelSummaries', [])}
                      
                      logger.info(f"Available Anthropic models: {list(available_models.keys())}")
                      
                      if model_id not in available_models:
                          logger.error(f"✗ Model {model_id} not found")
                          logger.error(f"Available models: {list(available_models.keys())}")
                          send_response(event, context, 'FAILED',
                                      {'Error': f'Model {model_id} not found in this region. Available: {", ".join(list(available_models.keys())[:5])}'})
                          return
                      
                      model_status = available_models[model_id].get('modelLifecycle', {}).get('status')
                      
                      if model_status != 'ACTIVE':
                          logger.error(f"✗ Model status: {model_status}")
                          send_response(event, context, 'FAILED',
                                      {'Error': f'Model not enabled. Go to Bedrock Console and enable {model_id}'})
                          return
                      
                      results['model_status'] = model_status
                      results['checks_passed'] += 1
                      logger.info(f"✓ Model {model_id} is ACTIVE")
                      
                  except ClientError as e:
                      logger.error(f"✗ Model check failed: {e}")
                      send_response(event, context, 'FAILED',
                                  {'Error': f'Failed to check model: {str(e)}'})
                      return
                  
                  # Check 3: Test invocation
                  logger.info("Check 3/3: Testing model invocation")
                  try:
                      test_body = json.dumps({
                          "anthropic_version": "bedrock-2023-05-31",
                          "max_tokens": 10,
                          "messages": [{"role": "user", "content": "test"}]
                      })
                      
                      response = bedrock_runtime.invoke_model(
                          modelId=model_id,
                          body=test_body
                      )
                      
                      results['model_invocation'] = 'SUCCESS'
                      results['checks_passed'] += 1
                      logger.info("✓ Model invocation successful")
                      
                  except ClientError as e:
                      logger.error(f"✗ Invocation failed: {e}")
                      send_response(event, context, 'FAILED',
                                  {'Error': f'Model invocation failed. Check IAM permissions.'})
                      return
                  
                  # All checks passed
                  response_data = {
                      'Message': 'All pre-checks passed',
                      'ChecksPassed': results['checks_passed'],
                      'ModelId': model_id,
                      'ModelStatus': model_status
                  }
                  
                  logger.info(f"✓ All checks passed: {response_data}")
                  send_response(event, context, 'SUCCESS', response_data)
                  
              except Exception as e:
                  logger.error(f"Unexpected error: {str(e)}", exc_info=True)
                  send_response(event, context, 'FAILED',
                              {'Error': f'Unexpected error: {str(e)}'})

  PrecheckInvocation:
    Type: Custom::PrecheckInvocation
    Condition: RunPrecheck
    DependsOn: PrecheckLambdaFunction
    Properties:
      ServiceToken: !GetAtt PrecheckLambdaFunction.Arn
      ModelId: !Ref ClawdbotModel

  # ==================== VPC and Network ====================
  ClawdbotVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "10.0.0.0/16"
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-vpc"

  ClawdbotInternetGateway:
    Type: AWS::EC2::InternetGateway

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref ClawdbotVPC
      InternetGatewayId: !Ref ClawdbotInternetGateway

  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ClawdbotVPC
      CidrBlock: "10.0.1.0/24"
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-public-subnet"

  PrivateSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ClawdbotVPC
      CidrBlock: "10.0.2.0/24"
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-private-subnet"

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ClawdbotVPC

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId: !Ref ClawdbotInternetGateway

  SubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable

  # VPC Endpoint Security Group
  VPCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: CreateEndpoints
    Properties:
      GroupDescription: "Security group for VPC endpoints"
      VpcId: !Ref ClawdbotVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref ClawdbotSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-vpce-sg"

  # Bedrock Runtime VPC Endpoint
  BedrockRuntimeVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Condition: CreateEndpoints
    Properties:
      VpcId: !Ref ClawdbotVPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.bedrock-runtime'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup

  # SSM VPC Endpoint (for Session Manager)
  SSMVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Condition: CreateEndpoints
    Properties:
      VpcId: !Ref ClawdbotVPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ssm'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup

  SSMMessagesVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Condition: CreateEndpoints
    Properties:
      VpcId: !Ref ClawdbotVPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ssmmessages'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup

  EC2MessagesVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Condition: CreateEndpoints
    Properties:
      VpcId: !Ref ClawdbotVPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ec2messages'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds:
        - !Ref PrivateSubnet
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup

  # ==================== IAM Role ====================
  ClawdbotInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'
        - 'arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy'
      Policies:
        - PolicyName: BedrockAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'bedrock:InvokeModel'
                  - 'bedrock:InvokeModelWithResponseStream'
                  - 'bedrock:ListFoundationModels'
                  - 'bedrock:GetFoundationModel'
                Resource: '*'
        - PolicyName: SSMParameterPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:PutParameter'
                  - 'ssm:GetParameter'
                Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/clawdbot/${AWS::StackName}/*'
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-instance-role"

  ClawdbotInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref ClawdbotInstanceRole

  # ==================== Security Group ====================
  ClawdbotSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Clawdbot instance security group"
      VpcId: !Ref ClawdbotVPC
      SecurityGroupIngress:
        - !If
          - AllowSSH
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIp: !Ref AllowedSSHCIDR
            Description: "SSH access (fallback)"
          - !Ref AWS::NoValue
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: "0.0.0.0/0"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-sg"

  # ==================== EC2 Instance ====================
  ClawdbotInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !FindInMap [RegionMap, !Ref "AWS::Region", AMI]
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyPairName
      IamInstanceProfile: !Ref ClawdbotInstanceProfile
      NetworkInterfaces:
        - AssociatePublicIpAddress: true
          DeviceIndex: 0
          GroupSet:
            - !Ref ClawdbotSecurityGroup
          SubnetId: !Ref PublicSubnet
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: 30
            VolumeType: gp3
            DeleteOnTermination: true
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          set -e
          
          exec > >(tee /var/log/clawdbot-setup.log)
          exec 2>&1
          
          echo "=========================================="
          echo "Clawdbot AWS Native Setup: $(date)"
          echo "=========================================="
          
          export DEBIAN_FRONTEND=noninteractive
          
          # System update
          echo "[1/9] Updating system..."
          apt-get update
          apt-get upgrade -y
          apt-get install -y unzip curl
          
          # Install AWS CLI v2
          echo "[2/9] Installing AWS CLI..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          ./aws/install
          rm -rf aws awscliv2.zip
          
          # Install SSM Agent (usually pre-installed)
          echo "[3/9] Configuring SSM Agent..."
          snap start amazon-ssm-agent || systemctl start amazon-ssm-agent
          
          # Install Docker
          echo "[4/9] Installing Docker..."
          curl -fsSL https://get.docker.com | sh
          systemctl enable docker
          systemctl start docker
          usermod -aG docker ubuntu
          
          # Install Node.js
          echo "[5/9] Installing Node.js..."
          sudo -u ubuntu bash << 'UBUNTU_SCRIPT'
          set -e
          cd ~
          
          # Install NVM (with retry)
          for i in {1..3}; do
            if curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash; then
              break
            fi
            echo "NVM installation failed, retrying $i/3..."
            sleep 5
          done
          
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          
          # Install Node.js 22
          nvm install 22
          nvm use 22
          nvm alias default 22
          
          # Install Clawdbot (with timeout and retry)
          npm config set registry https://registry.npmjs.org/
          npm install -g clawdbot@latest --timeout=300000 || {
            echo "Clawdbot installation failed, retrying..."
            npm cache clean --force
            npm install -g clawdbot@latest --timeout=300000
          }
          
          if ! grep -q 'NVM_DIR' ~/.bashrc; then
              echo 'export NVM_DIR="$HOME/.nvm"' >> ~/.bashrc
              echo '[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"' >> ~/.bashrc
          fi
          UBUNTU_SCRIPT
          
          # Configure AWS region
          echo "[6/9] Configuring AWS..."
          REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region)
          sudo -u ubuntu aws configure set region $REGION
          sudo -u ubuntu aws configure set output json
          
          # Configure environment variables
          echo "[7/9] Configuring environment variables..."
          cat >> /home/ubuntu/.bashrc << 'EOF'
          export AWS_REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region)
          export AWS_PROFILE=default
          export CLAWDBOT_MODEL="${ClawdbotModel}"
          export CLAWDBOT_USE_BEDROCK=true
          EOF
          
          # 启用 systemd linger
          loginctl enable-linger ubuntu
          systemctl start user@1000.service
          
          # 运行 Clawdbot onboarding
          echo "[8/9] Configuring Clawdbot..."
          
          # Create config directory
          sudo -u ubuntu mkdir -p /home/ubuntu/.clawdbot
          
          # Generate Gateway Token
          GATEWAY_TOKEN=$(openssl rand -hex 24)
          
          # Get AWS region (using IMDSv2)
          TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          AWS_REGION=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)
          
          # Create Bedrock configuration file
          sudo -u ubuntu cat > /home/ubuntu/.clawdbot/clawdbot.json << JSONEOF
          {
            "gateway": {
              "mode": "local",
              "port": 18789,
              "bind": "loopback",
              "controlUi": {
                "enabled": true,
                "allowInsecureAuth": true
              },
              "auth": {
                "mode": "token",
                "token": "$GATEWAY_TOKEN"
              }
            },
            "models": {
              "providers": {
                "amazon-bedrock": {
                  "baseUrl": "https://bedrock-runtime.$AWS_REGION.amazonaws.com",
                  "api": "bedrock-converse-stream",
                  "auth": "aws-sdk",
                  "models": [
                    {
                      "id": "${ClawdbotModel}",
                      "name": "Bedrock Model",
                      "input": ["text", "image"],
                      "contextWindow": 200000,
                      "maxTokens": 8192
                    }
                  ]
                }
              }
            },
            "agents": {
              "defaults": {
                "model": {
                  "primary": "amazon-bedrock/${ClawdbotModel}"
                }
              }
            }
          }
          JSONEOF
          
          # If sandbox enabled, add configuration
          if [ "${EnableSandbox}" == "true" ]; then
            sudo -u ubuntu python3 -c 'import json; config = json.load(open("/home/ubuntu/.clawdbot/clawdbot.json")); config["agents"]["defaults"]["sandbox"] = {"mode": "non-main", "allowlist": ["bash", "process", "read", "write", "edit"], "denylist": ["browser", "canvas", "nodes", "gateway"]}; json.dump(config, open("/home/ubuntu/.clawdbot/clawdbot.json", "w"), indent=2)'
          fi
          
          # Install daemon
          sudo -H -u ubuntu XDG_RUNTIME_DIR=/run/user/1000 bash -c '
          export HOME=/home/ubuntu
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          clawdbot daemon install || echo "Daemon install failed"
          '
          
          # Save token
          echo "$GATEWAY_TOKEN" > /home/ubuntu/.clawdbot/gateway_token.txt
          chown ubuntu:ubuntu /home/ubuntu/.clawdbot/gateway_token.txt
          
          # Get instance ID and region (using IMDSv2)
          TOKEN_IMDS=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          INSTANCE_ID=$(curl -H "X-aws-ec2-metadata-token: $TOKEN_IMDS" http://169.254.169.254/latest/meta-data/instance-id)
          
          # Save to SSM Parameter Store (so CloudFormation can retrieve it)
          STACK_NAME="${AWS::StackName}"
          aws ssm put-parameter \
            --name "/clawdbot/$STACK_NAME/gateway-token" \
            --value "$GATEWAY_TOKEN" \
            --type "SecureString" \
            --region $AWS_REGION \
            --overwrite || echo "Failed to save token to SSM"
          
          # Save instance info
          echo "$INSTANCE_ID" > /home/ubuntu/.clawdbot/instance_id.txt
          echo "$AWS_REGION" > /home/ubuntu/.clawdbot/region.txt
          
          # Create complete access instructions
          echo "Clawdbot Access Instructions" > /home/ubuntu/ACCESS_INSTRUCTIONS.txt
          echo "Run on LOCAL: aws ssm start-session --target $INSTANCE_ID --region $AWS_REGION --document-name AWS-StartPortForwardingSession --parameters '{\"portNumber\":[\"18789\"],\"localPortNumber\":[\"18789\"]}'" >> /home/ubuntu/ACCESS_INSTRUCTIONS.txt
          echo "Then open: http://localhost:18789/?token=$GATEWAY_TOKEN" >> /home/ubuntu/ACCESS_INSTRUCTIONS.txt
          chown ubuntu:ubuntu /home/ubuntu/ACCESS_INSTRUCTIONS.txt
          
          # Create SSM access script
          cat > /home/ubuntu/ssm-portforward.sh << 'EOF'
          #!/bin/bash
          INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
          REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region)
          TOKEN=$(cat /home/ubuntu/.clawdbot/gateway_token.txt)
          
          echo "=========================================="
          echo "Clawdbot SSM Port Forwarding"
          echo "=========================================="
          echo ""
          echo "Run on your local computer:"
          echo ""
          echo "aws ssm start-session \\"
          echo "  --target $INSTANCE_ID \\"
          echo "  --region $REGION \\"
          echo "  --document-name AWS-StartPortForwardingSession \\"
          echo "  --parameters '{\"portNumber\":[\"18789\"],\"localPortNumber\":[\"18789\"]}'"
          echo ""
          echo "Then open in browser:"
          echo "http://localhost:18789/?token=$TOKEN"
          echo ""
          echo "=========================================="
          EOF
          chmod +x /home/ubuntu/ssm-portforward.sh
          chown ubuntu:ubuntu /home/ubuntu/ssm-portforward.sh
          
          # 完成
          echo "[9/9] Complete!"
          echo "SUCCESS" > /home/ubuntu/.clawdbot/setup_status.txt
          echo "Setup completed: $(date)" >> /home/ubuntu/.clawdbot/setup_status.txt
          
          # Signal CloudFormation with token and instance info (using curl)
          SIGNAL_DATA="{\"Status\":\"SUCCESS\",\"Reason\":\"Clawdbot installation complete\",\"UniqueId\":\"$INSTANCE_ID\",\"Data\":\"{\\\"token\\\":\\\"$GATEWAY_TOKEN\\\",\\\"instanceId\\\":\\\"$INSTANCE_ID\\\",\\\"region\\\":\\\"$AWS_REGION\\\",\\\"accessUrl\\\":\\\"http://localhost:18789/?token=$GATEWAY_TOKEN\\\"}\"}"
          
          curl -X PUT -H 'Content-Type:' \
            --data-binary "$SIGNAL_DATA" \
            '${ClawdbotWaitHandle}' || echo "Failed to signal CloudFormation"
          
          echo "=========================================="
          echo "Clawdbot installation complete!"
          echo "Access via SSM Session Manager"
          echo "=========================================="
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-instance"

Outputs:
  InstanceId:
    Description: "EC2 Instance ID"
    Value: !Ref ClawdbotInstance
    Export:
      Name: !Sub "${AWS::StackName}-InstanceId"

  SSMSessionCommand:
    Description: "SSM Session Manager connection command"
    Value: !Sub "aws ssm start-session --target ${ClawdbotInstance} --region ${AWS::Region}"

  GatewayToken:
    Description: "Gateway Token (from WaitCondition)"
    Value: !GetAtt ClawdbotWaitCondition.Data

  SSMPortForwardCommand:
    Description: "STEP 1: Run on LOCAL computer (keep terminal open)"
    Value: !Sub |
      aws ssm start-session --target ${ClawdbotInstance} --region ${AWS::Region} --document-name AWS-StartPortForwardingSession --parameters '{"portNumber":["18789"],"localPortNumber":["18789"]}'

  CompleteAccessURL:
    Description: "STEP 2: Open this URL in browser (token included)"
    Value: !GetAtt ClawdbotWaitCondition.Data

  BedrockModel:
    Description: "Bedrock model in use"
    Value: !Ref ClawdbotModel

  PrecheckStatus:
    Description: "Pre-check status"
    Value: !If [RunPrecheck, "Pre-check completed", "Pre-check skipped"]
    Condition: RunPrecheck

  VPCEndpointsCreated:
    Description: "VPC endpoints status"
    Value: !If [CreateEndpoints, "VPC endpoints created (private network)", "VPC endpoints not created (public internet)"]

  SecurityNote:
    Description: "Security configuration"
    Value: "Uses IAM authentication for Bedrock, SSM Session Manager for access, no API keys needed"

  NextSteps:
    Description: "Complete setup instructions"
    Value: !Sub |
      STEP 1: Wait 5-10 minutes for installation to complete
      
      STEP 2: Install SSM Session Manager Plugin on your local computer (if not already installed)
      - macOS: https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html
      - Run: session-manager-plugin --version (to verify)
      
      STEP 3: Start port forwarding (run on your LOCAL computer, keep terminal open)
      aws ssm start-session \
        --target ${ClawdbotInstance} \
        --region ${AWS::Region} \
        --document-name AWS-StartPortForwardingSession \
        --parameters '{"portNumber":["18789"],"localPortNumber":["18789"]}'
      
      STEP 4: Get Gateway Token (open NEW terminal)
      aws ssm start-session --target ${ClawdbotInstance} --region ${AWS::Region}
      Then run: sudo su - ubuntu && cat ~/.clawdbot/gateway_token.txt
      Copy the token (48-character hex string)
      
      STEP 5: Open in browser
      http://localhost:18789/?token=<paste-your-token-here>
      
      STEP 6: Connect messaging platforms (WhatsApp, Telegram, Discord, etc.)
      See README for detailed instructions: https://github.com/JiaDe-Wu/clawdbot-aws-bedrock

  MonthlyCost:
    Description: "Estimated monthly cost (USD)"
    Value: !Sub |
      EC2 (${InstanceType}): ~$30-40
      EBS (30GB): ~$2.40
      VPC Endpoints: ${!If [CreateEndpoints, "~$22 ($0.01/hour per endpoint)", "$0"]}
      Bedrock: Pay-per-use
      Total: ~${!If [CreateEndpoints, "$55-65", "$33-43"]}/month
